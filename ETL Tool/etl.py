#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# GUI module generated by PAGE version 5.0.2
#  in conjunction with Tcl version 8.6
#    May 23, 2020 08:13:34 PM IST  platform: Windows NT

import sys
from tkinter import messagebox

try:
    import Tkinter as tk
except ImportError:
    import tkinter as tk

try:
    import ttk

    py3 = False
except ImportError:
    import tkinter.ttk as ttk

    py3 = True

import etl_support
import pyodbc
from tkinter import *

conn = pyodbc.connect('Driver={SQL Server};'
                      'Server=DESKTOP-FCAMJHE\SQLEXPRESS;'
                      'Database=p4;'
                      'Trusted_Connection=yes;')
cursor = conn.cursor()


def vp_start_gui():
    '''Starting point when module is the main routine.'''
    global val, w, root
    root = tk.Tk()
    etl_support.set_Tk_var()
    top = Toplevel1(root)
    etl_support.init(root, top)
    root.mainloop()


w = None


def create_Toplevel1(rt, *args, **kwargs):
    '''Starting point when module is imported by another module.
       Correct form of call: 'create_Toplevel1(root, *args, **kwargs)' .'''
    global w, w_win, root
    # rt = root
    root = rt
    w = tk.Toplevel(root)
    etl_support.set_Tk_var()
    top = Toplevel1(w)
    etl_support.init(w, top, *args, **kwargs)
    return (w, top)

attrlist=[]

def destroy_Toplevel1():
    global w
    w.destroy()
    w = None

class Toplevel1:
    
    # Triggering function for Dimension drop down
    def first_ok_method(self, event):
        
        # Selected dimension
        first_combo_value = str(self.first_combo.get())
        self.second_combo.set("")
        
        # Fetch attributes, type for selected dimension
        dropList = []
        cursor.execute("select distinct attribute_name,change_type from dbo.category_changeType where lower(category_name) = lower('{}') union select attribute,'type-1' change_type from infoAttribute where lower(p_info) = lower('{}');".format(first_combo_value,first_combo_value))
        for row in cursor:
            dropList.append([str(row[0])+", "+str(row[1])])
        
        # Populate the attribute drop down with the list
        self.second_combo['values'] = dropList

    def second_ok_method(self, event):
        
        # Selected dimension
        first_combo_value = str(self.first_combo.get())
        
        # Fetch all columns of selected dimension table
        cursor.execute("select COLUMN_NAME from INFORMATION_SCHEMA.COLUMNS where lower(table_Name)=lower('{}_table');".format(first_combo_value.replace(' ','_')))
        attrlist.clear()
        dropList = str()
        for row in cursor:
            attrlist.append(str(row[0]).strip())
            dropList+=str(row[0]).strip()+"\t\t"
        
        # Show all contents of the dimension table selected
        cursor.execute("select * from {}_TABLE;".format(first_combo_value.replace(' ','_')))
        attrlist.remove(first_combo_value.replace(' ','_')+'_id')
        for row in cursor:
            itemstr=str()
            for item in row:
                itemstr+=str(item).strip()+"\t\t"
            dropList+="\n"+itemstr

        self.table_display.config(state=NORMAL)
        self.table_display.delete('1.0', END)
        self.table_display.insert(INSERT,dropList)
        self.table_display.config(state=DISABLED)

    def submitmethod(self):
        self.table_display.config(state=NORMAL)
        
        # Selected dimension
        first_combo_value = str(self.first_combo.get())
        first_combo_value = first_combo_value.replace(' ','_')

        # Selected attribute: attribute_name,type
        second_combo_value = str(self.second_combo.get())
        second_combo_value = second_combo_value.replace('{','')
        second_combo_value = second_combo_value.replace('}','')
        second_combo_value = second_combo_value.split(',')
        second_combo_value = [x.strip().replace(' ','_') for x in second_combo_value]
        
        # Entered value: row_id,value
        new_value = str(self.new_val_entry.get())
        new_value = new_value.split(',')
        new_value = [x.strip() for x in new_value]
        
        typeAtr=str()
        try:
            cursor.execute("select data_type from INFORMATION_SCHEMA.COLUMNS where lower(TABLE_NAME)=lower('{}_table') and lower(COLUMN_NAME)=lower('{}');".format(first_combo_value,second_combo_value[0]))
            for row in cursor:
                typeAtr=row[0]

            # Update for type-1
            if second_combo_value[1]=='type-1':
                # Non-Numeric columns
                if typeAtr in ['date','text','timestamp']:
                    cursor.execute("update {}_table set {}='{}' where {}_id={};".format(first_combo_value, second_combo_value[0], new_value[1], first_combo_value, new_value[0]))
                # Numeric columns
                else:
                    cursor.execute("update {}_table set {}={} where {}_id={};".format(first_combo_value, second_combo_value[0], new_value[1], first_combo_value, new_value[0]))
                cursor.commit()
            # Insert new row for type-2
            else:
                # Insert new row with new value
                s=str()
                for x in attrlist:
                    s+=x.replace(" ","_")+","
                s=s[:-1]
                cursor.execute("Insert into {}_table ({}) select {} from {}_table where {}_id={};".format(first_combo_value,s,s,first_combo_value,first_combo_value, new_value[0]))
                cursor.commit()
                
                # Newly inserted row's id
                cursor.execute("select max({}_id) from {}_table;".format(first_combo_value,first_combo_value))
                maxid=int()
                for row in cursor:
                    maxid=row[0]
                
                # Update selected attribute for newly inserted row
                # Non-Numeric columns
                if typeAtr in ['date','text','timestamp']:
                    cursor.execute("update {}_table set {}='{}' where {}_id={};".format(first_combo_value, second_combo_value[0], new_value[1], first_combo_value, maxid))
                # Numeric columns
                else:
                    cursor.execute("update {}_table set {}={} where {}_id={};".format(first_combo_value, second_combo_value[0], new_value[1], first_combo_value, maxid))
                cursor.commit()
                
            # Fetch all columns of selected dimension table
            cursor.execute("select COLUMN_NAME from INFORMATION_SCHEMA.COLUMNS where lower(table_Name)=lower('{}_table');".format(
                    first_combo_value.replace(' ', '_')))
            dropList = str()
            for row in cursor:
                dropList += str(row[0]).strip() + "\t\t"
            
            # Entered value: row_id,value
            cursor.execute("select * from {}_TABLE;".format(first_combo_value.replace(' ', '_')))
            for row in cursor:
                itemstr = str()
                for item in row:
                    itemstr += str(item).strip() + "\t\t"
                dropList += "\n" + itemstr
            self.table_display.delete('1.0', END)
            self.table_display.insert(INSERT, dropList)
            self.table_display.config(state=DISABLED)
            
            # Success message
            messagebox.showinfo("Message Box", "Successfully updated")
        except:
            # Failure message
            messagebox.showerror("Message Box", "Update Unsuccessful")


    def __init__(self, top=None):
        '''This class configures and populates the toplevel window.
           top is the toplevel containing window.'''
        _bgcolor = '#d9d9d9'  # X11 color: 'gray85'
        _fgcolor = '#000000'  # X11 color: 'black'
        _compcolor = '#d9d9d9'  # X11 color: 'gray85'
        _ana1color = '#d9d9d9'  # X11 color: 'gray85'
        _ana2color = '#ececec'  # Closest X11 color: 'gray92'
        font12 = "-family {Segoe UI} -size 11"
        font9 = "-family {Segoe UI} -size 14"
        self.style = ttk.Style()
        if sys.platform == "win32":
            self.style.theme_use('winnative')
        self.style.configure('.', background=_bgcolor)
        self.style.configure('.', foreground=_fgcolor)
        self.style.configure('.', font="TkDefaultFont")
        self.style.map('.', background=
        [('selected', _compcolor), ('active', _ana2color)])

        top.geometry("1920x1001+-11+2")
        top.attributes("-fullscreen", True)
        top.minsize(148, 1)
        top.maxsize(1924, 1055)
        top.resizable(1, 1)
        top.title("New Toplevel")
        top.configure(background="#2E5470")
        top.configure(highlightbackground="#d9d9d9")
        top.configure(highlightcolor="black")

        self.title = tk.Label(top)
        self.title.place(relx=0.230, rely=0.02, height=86, width=795)
        self.title.configure(activebackground="#f9f9f9")
        self.title.configure(activeforeground="black")
        self.title.configure(background="#2E5470")
        self.title.configure(disabledforeground="#a3a3a3")
        self.title.configure(font="-family {Segoe UI} -size 24")
        self.title.configure(foreground="#ffffff")
        self.title.configure(highlightbackground="#d9d9d9")
        self.title.configure(highlightcolor="black")
        self.title.configure(text='''ETL process for type1 & type2 changes''')

        # populate list from db for first drop down
        cursor.execute("select distinct attribute from infoAttribute where dataType='data object' union select distinct category_name from dbo.category_changeType;")

        category_name=[]
        for row in cursor:
            category_name.append(row[0])
        # print(category_name)
        values_list_1 = category_name

        self.first_combo = ttk.Combobox(top, values=values_list_1, state='readonly')
        self.first_combo.place(relx=0.719, rely=0.19, relheight=0.036
                               , relwidth=0.181)
        self.first_combo.configure(textvariable=etl_support.combobox)
        self.first_combo.configure(takefocus="")
        self.first_combo.bind('<<ComboboxSelected>>', self.first_ok_method)

        self.second_combo = ttk.Combobox(top, values=[], state='readonly')
        self.second_combo.place(relx=0.719, rely=0.34, relheight=0.036
                                , relwidth=0.181)
        self.second_combo.configure(textvariable=etl_support.combobox2)
        self.second_combo.configure(takefocus="")
        self.second_combo.bind('<<ComboboxSelected>>', self.second_ok_method)

        self.close_button = tk.Button(top)
        self.close_button.place(relx=0.911, rely=0.05, height=52, width=89)
        self.close_button.configure(activebackground="#ececec")
        self.close_button.configure(activeforeground="#000000")
        self.close_button.configure(background="#ac0929")
        self.close_button.configure(disabledforeground="#a3a3a3")
        self.close_button.configure(font="-family {Segoe UI} -size 14")
        self.close_button.configure(foreground="#ffffff")
        self.close_button.configure(highlightbackground="#d9d9d9")
        self.close_button.configure(highlightcolor="black")
        self.close_button.configure(pady="0")
        self.close_button.configure(text='''Close''')
        self.close_button.configure(command=root.destroy)

        self.new_val = tk.Label(top)
        self.new_val.place(relx=0.69, rely=0.509, height=36, width=350)
        self.new_val.configure(activebackground="#f9f9f9")
        self.new_val.configure(activeforeground="black")
        self.new_val.configure(background="#2E5470")
        self.new_val.configure(disabledforeground="#a3a3a3")
        self.new_val.configure(font="-family {Segoe UI} -size 14")
        self.new_val.configure(foreground="#ffffff")
        self.new_val.configure(highlightbackground="#d9d9d9")
        self.new_val.configure(highlightcolor="black")
        self.new_val.configure(text='''Enter New Value (Primary Key, Value)''')

        self.new_val_entry = tk.Entry(top)
        self.new_val_entry.place(relx=0.672, rely=0.569, height=34
                                 , relwidth=0.273)
        self.new_val_entry.configure(background="white")
        self.new_val_entry.configure(disabledforeground="#a3a3a3")
        self.new_val_entry.configure(font="TkFixedFont")
        self.new_val_entry.configure(foreground="#000000")
        self.new_val_entry.configure(highlightbackground="#d9d9d9")
        self.new_val_entry.configure(highlightcolor="black")
        self.new_val_entry.configure(insertbackground="black")
        self.new_val_entry.configure(selectbackground="#c4c4c4")
        self.new_val_entry.configure(selectforeground="black")

        self.submit_btn = tk.Button(top)
        self.submit_btn.place(relx=0.771, rely=0.639, height=43, width=133)
        self.submit_btn.configure(activebackground="#ececec")
        self.submit_btn.configure(activeforeground="#000000")
        self.submit_btn.configure(background="#d9d9d9")
        self.submit_btn.configure(disabledforeground="#a3a3a3")
        self.submit_btn.configure(font=font9)
        self.submit_btn.configure(foreground="#000000")
        self.submit_btn.configure(highlightbackground="#d9d9d9")
        self.submit_btn.configure(highlightcolor="black")
        self.submit_btn.configure(pady="0")
        self.submit_btn.configure(text='''Submit''')
        self.submit_btn.configure(command=self.submitmethod)

        self.current_val_1 = tk.Label(top)
        self.current_val_1.place(relx=0.745, rely=0.14, height=36, width=203)
        self.current_val_1.configure(activebackground="#f9f9f9")
        self.current_val_1.configure(activeforeground="black")
        self.current_val_1.configure(background="#2E5470")
        self.current_val_1.configure(disabledforeground="#a3a3a3")
        self.current_val_1.configure(font="-family {Segoe UI} -size 14")
        self.current_val_1.configure(foreground="#ffffff")
        self.current_val_1.configure(highlightbackground="#d9d9d9")
        self.current_val_1.configure(highlightcolor="black")
        self.current_val_1.configure(text='''Dimension Name''')

        self.currentval_2 = tk.Label(top)
        self.currentval_2.place(relx=0.745, rely=0.29, height=36, width=203)
        self.currentval_2.configure(activebackground="#f9f9f9")
        self.currentval_2.configure(activeforeground="black")
        self.currentval_2.configure(background="#2E5470")
        self.currentval_2.configure(disabledforeground="#a3a3a3")
        self.currentval_2.configure(font="-family {Segoe UI} -size 14")
        self.currentval_2.configure(foreground="#ffffff")
        self.currentval_2.configure(highlightbackground="#d9d9d9")
        self.currentval_2.configure(highlightcolor="black")
        self.currentval_2.configure(text='''Attribute Name''')

        self.table_display = ScrolledText(top)
        self.table_display.place(relx=0.047, rely=0.14, relheight=0.827
                                 , relwidth=0.469)
        self.table_display.configure(background="white")
        self.table_display.configure(font="TkTextFont")
        self.table_display.configure(foreground="black")
        self.table_display.configure(highlightbackground="#d9d9d9")
        self.table_display.configure(highlightcolor="black")
        self.table_display.configure(insertbackground="black")
        self.table_display.configure(insertborderwidth="3")
        self.table_display.configure(padx="25")
        self.table_display.configure(pady="25")
        self.table_display.configure(selectbackground="#c4c4c4")
        self.table_display.configure(selectforeground="black")
        self.table_display.configure(wrap="none")


# The following code is added to facilitate the Scrolled widgets you specified.
class AutoScroll(object):
    '''Configure the scrollbars for a widget.'''

    def __init__(self, master):
        #  Rozen. Added the try-except clauses so that this class
        #  could be used for scrolled entry widget for which vertical
        #  scrolling is not supported. 5/7/14.
        try:
            vsb = ttk.Scrollbar(master, orient='vertical', command=self.yview)
        except:
            pass
        hsb = ttk.Scrollbar(master, orient='horizontal', command=self.xview)
        try:
            self.configure(yscrollcommand=self._autoscroll(vsb))
        except:
            pass
        self.configure(xscrollcommand=self._autoscroll(hsb))
        self.grid(column=0, row=0, sticky='nsew')
        try:
            vsb.grid(column=1, row=0, sticky='ns')
        except:
            pass
        hsb.grid(column=0, row=1, sticky='ew')
        master.grid_columnconfigure(0, weight=1)
        master.grid_rowconfigure(0, weight=1)
        # Copy geometry methods of master  (taken from ScrolledText.py)
        if py3:
            methods = tk.Pack.__dict__.keys() | tk.Grid.__dict__.keys() \
                      | tk.Place.__dict__.keys()
        else:
            methods = tk.Pack.__dict__.keys() + tk.Grid.__dict__.keys() \
                      + tk.Place.__dict__.keys()
        for meth in methods:
            if meth[0] != '_' and meth not in ('config', 'configure'):
                setattr(self, meth, getattr(master, meth))

    @staticmethod
    def _autoscroll(sbar):
        '''Hide and show scrollbar as needed.'''

        def wrapped(first, last):
            first, last = float(first), float(last)
            if first <= 0 and last >= 1:
                sbar.grid_remove()
            else:
                sbar.grid()
            sbar.set(first, last)

        return wrapped

    def __str__(self):
        return str(self.master)


def _create_container(func):
    '''Creates a ttk Frame with a given master, and use this new frame to
    place the scrollbars and the widget.'''

    def wrapped(cls, master, **kw):
        container = ttk.Frame(master)
        container.bind('<Enter>', lambda e: _bound_to_mousewheel(e, container))
        container.bind('<Leave>', lambda e: _unbound_to_mousewheel(e, container))
        return func(cls, container, **kw)

    return wrapped


class ScrolledText(AutoScroll, tk.Text):
    '''A standard Tkinter Text widget with scrollbars that will
    automatically show/hide as needed.'''

    @_create_container
    def __init__(self, master, **kw):
        tk.Text.__init__(self, master, **kw)
        AutoScroll.__init__(self, master)


import platform


def _bound_to_mousewheel(event, widget):
    child = widget.winfo_children()[0]
    if platform.system() == 'Windows' or platform.system() == 'Darwin':
        child.bind_all('<MouseWheel>', lambda e: _on_mousewheel(e, child))
        child.bind_all('<Shift-MouseWheel>', lambda e: _on_shiftmouse(e, child))
    else:
        child.bind_all('<Button-4>', lambda e: _on_mousewheel(e, child))
        child.bind_all('<Button-5>', lambda e: _on_mousewheel(e, child))
        child.bind_all('<Shift-Button-4>', lambda e: _on_shiftmouse(e, child))
        child.bind_all('<Shift-Button-5>', lambda e: _on_shiftmouse(e, child))


def _unbound_to_mousewheel(event, widget):
    if platform.system() == 'Windows' or platform.system() == 'Darwin':
        widget.unbind_all('<MouseWheel>')
        widget.unbind_all('<Shift-MouseWheel>')
    else:
        widget.unbind_all('<Button-4>')
        widget.unbind_all('<Button-5>')
        widget.unbind_all('<Shift-Button-4>')
        widget.unbind_all('<Shift-Button-5>')


def _on_mousewheel(event, widget):
    if platform.system() == 'Windows':
        widget.yview_scroll(-1 * int(event.delta / 120), 'units')
    elif platform.system() == 'Darwin':
        widget.yview_scroll(-1 * int(event.delta), 'units')
    else:
        if event.num == 4:
            widget.yview_scroll(-1, 'units')
        elif event.num == 5:
            widget.yview_scroll(1, 'units')


def _on_shiftmouse(event, widget):
    if platform.system() == 'Windows':
        widget.xview_scroll(-1 * int(event.delta / 120), 'units')
    elif platform.system() == 'Darwin':
        widget.xview_scroll(-1 * int(event.delta), 'units')
    else:
        if event.num == 4:
            widget.xview_scroll(-1, 'units')
        elif event.num == 5:
            widget.xview_scroll(1, 'units')


if __name__ == '__main__':
    vp_start_gui()
